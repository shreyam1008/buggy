<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>English ↔ Nepali Date Converter</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
      * {
        box-sizing: border-box;
      }
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        padding: 1rem;
        max-width: 480px;
        margin: auto;
        background: #f8f9fa;
        color: #333;
      }
      .container {
        background: white;
        border-radius: 8px;
        padding: 1.5rem;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }
      input {
        width: 100%;
        font-size: 1.1rem;
        padding: 12px;
        margin: 8px 0 16px 0;
        border: 2px solid #e1e5e9;
        border-radius: 6px;
        transition: border-color 0.3s;
      }
      input:focus {
        outline: none;
        border-color: #0066cc;
      }
      input.error {
        border-color: #dc3545;
        background: #fff5f5;
      }
      input.success {
        border-color: #28a745;
        background: #f8fff8;
      }
      label {
        font-weight: 600;
        color: #555;
        display: block;
        margin-top: 1rem;
      }
      label:first-of-type {
        margin-top: 0;
      }
      .hint {
        font-size: 0.85rem;
        color: #666;
        margin-bottom: 1rem;
        text-align: center;
        background: #f1f3f4;
        padding: 8px;
        border-radius: 4px;
      }
      header {
        text-align: center;
        margin-bottom: 1.5rem;
      }
      header h2 {
        margin: 0 0 0.5rem 0;
        color: #2c3e50;
      }
      .status {
        min-height: 24px;
        margin-top: 1rem;
        padding: 8px 12px;
        border-radius: 4px;
        font-size: 0.9rem;
        font-weight: 500;
        text-align: center;
        transition: all 0.3s;
      }
      .status.error {
        background: #f8d7da;
        color: #721c24;
        border: 1px solid #f5c6cb;
      }
      .status.success {
        background: #d4edda;
        color: #155724;
        border: 1px solid #c3e6cb;
      }
      .status.info {
        background: #d1ecf1;
        color: #0c5460;
        border: 1px solid #bee5eb;
      }
      footer {
        font-size: 0.8rem;
        color: #666;
        margin-top: 1.5rem;
        text-align: center;
        line-height: 1.4;
      }
      .format-help {
        font-size: 0.8rem;
        color: #666;
        margin-top: 4px;
      }
      @media (max-width: 480px) {
        body {
          padding: 0.5rem;
        }
        .container {
          padding: 1rem;
        }
        input {
          font-size: 16px;
        } /* prevents zoom on iOS */
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h2>English ↔ Nepali Date Converter</h2>
        <div class="hint">
          Enter date in either format - conversion happens instantly
        </div>
      </header>

      <label for="adInput">AD (English Date)</label>
      <input
        id="adInput"
        placeholder="14/04/1943 or 04-14-1943"
        autocomplete="off"
      />
      <div class="format-help">
        Supports: DD/MM/YYYY, MM/DD/YYYY, DD-MM-YYYY, DD.MM.YYYY
      </div>

      <label for="bsInput">BS (Nepali Date)</label>
      <input
        id="bsInput"
        placeholder="01/01/2000 or 20000101"
        autocomplete="off"
      />
      <div class="format-help">
        Supports: DD/MM/YYYY, MM/DD/YYYY, DD-MM-YYYY, YYYYMMDD
      </div>

      <div id="status" class="status"></div>

      <footer>
        Works offline • Range: BS 2000-2089 (AD 1943-2032)<br />
        Save to home screen for quick access
      </footer>
    </div>

    <script>
      const bsMonthData = {
        2000: [30, 32, 31, 32, 31, 30, 29, 30, 29, 30, 29, 31],
        2001: [31, 31, 31, 32, 31, 30, 30, 29, 30, 29, 30, 30],
        2002: [31, 31, 32, 31, 31, 30, 30, 29, 30, 29, 30, 30],
        2003: [31, 32, 31, 32, 31, 30, 29, 30, 29, 30, 29, 31],
        2004: [30, 32, 31, 32, 31, 30, 29, 30, 29, 30, 29, 31],
        2005: [31, 31, 31, 32, 31, 30, 30, 29, 30, 29, 30, 30],
        2006: [31, 31, 32, 31, 31, 30, 30, 29, 30, 29, 30, 30],
        2007: [31, 32, 31, 32, 31, 30, 29, 30, 29, 30, 29, 31],
        2008: [30, 32, 31, 32, 31, 30, 29, 30, 29, 30, 29, 31],
        2009: [31, 31, 31, 32, 31, 30, 30, 29, 30, 29, 30, 30],
        2010: [31, 31, 32, 31, 31, 30, 30, 29, 30, 29, 30, 30],
        2011: [31, 32, 31, 32, 31, 30, 29, 30, 29, 30, 29, 31],
        2012: [31, 31, 31, 32, 31, 30, 29, 30, 30, 29, 30, 30],
        2013: [31, 31, 32, 31, 31, 30, 29, 30, 30, 29, 30, 30],
        2014: [31, 32, 31, 32, 31, 30, 29, 30, 29, 30, 29, 31],
        2015: [31, 31, 31, 32, 31, 30, 29, 30, 30, 29, 30, 30],
        2016: [31, 31, 32, 31, 31, 30, 29, 30, 30, 29, 30, 30],
        2017: [31, 32, 31, 32, 31, 30, 29, 30, 29, 30, 29, 31],
        2018: [31, 31, 31, 32, 31, 30, 29, 30, 30, 29, 30, 30],
        2019: [31, 31, 32, 31, 31, 30, 29, 30, 30, 29, 30, 30],
        2020: [31, 32, 31, 32, 31, 30, 29, 30, 29, 30, 29, 31],
        2021: [31, 31, 31, 32, 31, 30, 29, 30, 30, 29, 30, 30],
        2022: [31, 31, 32, 31, 31, 30, 29, 30, 30, 29, 30, 30],
        2023: [31, 32, 31, 32, 31, 30, 29, 30, 29, 30, 29, 31],
        2024: [31, 31, 31, 32, 31, 30, 29, 30, 30, 29, 30, 30],
        2025: [31, 31, 32, 31, 31, 30, 29, 30, 30, 29, 30, 30],
        2026: [31, 32, 31, 32, 31, 30, 29, 30, 29, 30, 29, 31],
        2027: [31, 31, 31, 32, 31, 30, 29, 30, 30, 29, 30, 30],
        2028: [31, 31, 32, 31, 31, 30, 29, 30, 30, 29, 30, 30],
        2029: [31, 32, 31, 32, 31, 30, 29, 30, 29, 30, 29, 31],
        2030: [31, 31, 31, 32, 31, 30, 29, 30, 30, 29, 30, 30],
        2031: [31, 31, 32, 31, 31, 30, 29, 30, 30, 29, 30, 30],
        2032: [31, 32, 31, 32, 31, 30, 29, 30, 29, 30, 29, 31],
        2033: [31, 31, 31, 32, 31, 30, 29, 30, 30, 29, 30, 30],
        2034: [31, 31, 32, 31, 31, 30, 29, 30, 30, 29, 30, 30],
        2035: [31, 32, 31, 32, 31, 30, 29, 30, 29, 30, 29, 31],
        2036: [31, 31, 31, 32, 31, 30, 29, 30, 30, 29, 30, 30],
        2037: [31, 31, 32, 31, 31, 30, 29, 30, 30, 29, 30, 30],
        2038: [31, 32, 31, 32, 31, 30, 29, 30, 29, 30, 29, 31],
        2039: [31, 31, 31, 32, 31, 30, 29, 30, 30, 29, 30, 30],
        2040: [31, 31, 32, 31, 31, 30, 29, 30, 30, 29, 30, 30],
        2041: [31, 32, 31, 32, 31, 30, 29, 30, 29, 30, 29, 31],
        2042: [31, 31, 31, 32, 31, 30, 29, 30, 30, 29, 30, 30],
        2043: [31, 31, 32, 31, 31, 30, 29, 30, 30, 29, 30, 30],
        2044: [31, 32, 31, 32, 31, 30, 29, 30, 29, 30, 29, 31],
        2045: [31, 31, 31, 32, 31, 30, 29, 30, 30, 29, 30, 30],
        2046: [31, 31, 32, 31, 31, 30, 29, 30, 30, 29, 30, 30],
        2047: [31, 32, 31, 32, 31, 30, 29, 30, 29, 30, 29, 31],
        2048: [31, 31, 31, 32, 31, 30, 29, 30, 30, 29, 30, 30],
        2049: [31, 31, 32, 31, 31, 30, 29, 30, 30, 29, 30, 30],
        2050: [31, 32, 31, 32, 31, 30, 29, 30, 29, 30, 29, 31],
        2051: [31, 31, 31, 32, 31, 30, 29, 30, 30, 29, 30, 30],
        2052: [31, 31, 32, 31, 31, 30, 29, 30, 30, 29, 30, 30],
        2053: [31, 32, 31, 32, 31, 30, 29, 30, 29, 30, 29, 31],
        2054: [31, 31, 31, 32, 31, 30, 29, 30, 30, 29, 30, 30],
        2055: [31, 31, 32, 31, 31, 30, 29, 30, 30, 29, 30, 30],
        2056: [31, 32, 31, 32, 31, 30, 29, 30, 29, 30, 29, 31],
        2057: [31, 31, 31, 32, 31, 30, 29, 30, 30, 29, 30, 30],
        2058: [31, 31, 32, 31, 31, 30, 29, 30, 30, 29, 30, 30],
        2059: [31, 32, 31, 32, 31, 30, 29, 30, 29, 30, 29, 31],
        2060: [31, 31, 31, 32, 31, 30, 29, 30, 30, 29, 30, 30],
        2061: [31, 31, 32, 31, 31, 30, 29, 30, 30, 29, 30, 30],
        2062: [31, 32, 31, 32, 31, 30, 29, 30, 29, 30, 29, 31],
        2063: [31, 31, 31, 32, 31, 30, 29, 30, 30, 29, 30, 30],
        2064: [31, 31, 32, 31, 31, 30, 29, 30, 30, 29, 30, 30],
        2065: [31, 32, 31, 32, 31, 30, 29, 30, 29, 30, 29, 31],
        2066: [31, 31, 31, 32, 31, 30, 29, 30, 30, 29, 30, 30],
        2067: [31, 31, 32, 31, 31, 30, 29, 30, 30, 29, 30, 30],
        2068: [31, 32, 31, 32, 31, 30, 29, 30, 29, 30, 29, 31],
        2069: [31, 31, 31, 32, 31, 30, 29, 30, 30, 29, 30, 30],
        2070: [31, 31, 32, 31, 31, 30, 29, 30, 30, 29, 30, 30],
        2071: [31, 32, 31, 32, 31, 30, 29, 30, 29, 30, 29, 31],
        2072: [31, 31, 31, 32, 31, 30, 29, 30, 30, 29, 30, 30],
        2073: [31, 31, 32, 31, 31, 30, 29, 30, 30, 29, 30, 30],
        2074: [31, 32, 31, 32, 31, 30, 29, 30, 29, 30, 29, 31],
        2075: [31, 31, 31, 32, 31, 30, 29, 30, 30, 29, 30, 30],
        2076: [31, 31, 32, 31, 31, 30, 29, 30, 30, 29, 30, 30],
        2077: [31, 32, 31, 32, 31, 30, 29, 30, 29, 30, 29, 31],
        2078: [31, 31, 31, 32, 31, 30, 29, 30, 30, 29, 30, 30],
        2079: [31, 31, 32, 31, 31, 30, 29, 30, 30, 29, 30, 30],
        2080: [31, 32, 31, 32, 31, 30, 29, 30, 29, 30, 29, 31],
        2081: [31, 31, 31, 32, 31, 30, 29, 30, 30, 29, 30, 30],
        2082: [31, 31, 32, 31, 31, 30, 29, 30, 30, 29, 30, 30],
        2083: [31, 32, 31, 32, 31, 30, 29, 30, 29, 30, 29, 31],
        2084: [31, 31, 31, 32, 31, 30, 29, 30, 30, 29, 30, 30],
        2085: [31, 31, 32, 31, 31, 30, 29, 30, 30, 29, 30, 30],
        2086: [31, 32, 31, 32, 31, 30, 29, 30, 29, 30, 29, 31],
        2087: [31, 31, 31, 32, 31, 30, 29, 30, 30, 29, 30, 30],
        2088: [31, 31, 32, 31, 31, 30, 29, 30, 30, 29, 30, 30],
        2089: [31, 32, 31, 32, 31, 30, 29, 30, 29, 30, 29, 31],
      };

      const anchorAd = new Date(Date.UTC(1943, 3, 14));
      const anchorBs = { y: 2000, m: 1, d: 1 };

      function convertAdToBs(adDate) {
        const diffDays = Math.floor((adDate - anchorAd) / 86400000);
        let y = anchorBs.y,
          m = anchorBs.m,
          d = anchorBs.d;
        let remain = diffDays;
        if (remain >= 0) {
          while (remain--) {
            d++;
            if (d > bsMonthData[y][m - 1]) {
              d = 1;
              m++;
              if (m > 12) {
                m = 1;
                y++;
              }
            }
          }
        } else {
          while (remain++) {
            d--;
            if (d < 1) {
              m--;
              if (m < 1) {
                y--;
                m = 12;
              }
              d = bsMonthData[y][m - 1];
            }
          }
        }
        return { y, m, d };
      }

      function convertBsToAd(y, m, d) {
        let adDate = new Date(anchorAd);
        let yy = anchorBs.y,
          mm = anchorBs.m,
          dd = anchorBs.d;
        while (yy < y || (yy === y && (mm < m || (mm === m && dd < d)))) {
          adDate = new Date(adDate.getTime() + 86400000);
          dd++;
          if (dd > bsMonthData[yy][mm - 1]) {
            dd = 1;
            mm++;
            if (mm > 12) {
              mm = 1;
              yy++;
            }
          }
        }
        while (yy > y || (yy === y && (mm > m || (mm === m && dd > d)))) {
          adDate = new Date(adDate.getTime() - 86400000);
          dd--;
          if (dd < 1) {
            mm--;
            if (mm < 1) {
              yy--;
              mm = 12;
            }
            dd = bsMonthData[yy][mm - 1];
          }
        }
        return adDate;
      }

      function parseAdInput(input) {
        input = input.replace(/\s/g, "");

        // Handle DDMMYYYY or MMDDYYYY without separators
        if (/^\d{8}$/.test(input)) {
          const dd1 = parseInt(input.substring(0, 2));
          const mm1 = parseInt(input.substring(2, 4));
          const yyyy = parseInt(input.substring(4, 8));

          // Try DD/MM/YYYY first if day > 12 or month <= 12
          if (dd1 > 12 || (dd1 <= 12 && mm1 <= 12 && dd1 > mm1)) {
            if (isValidAdParts(yyyy, mm1, dd1)) {
              // Auto-format and update display
              setTimeout(() => {
                adInput.value = `${String(dd1).padStart(2, "0")}/${String(
                  mm1
                ).padStart(2, "0")}/${yyyy}`;
              }, 0);
              return { y: yyyy, m: mm1, d: dd1 };
            }
          }
          // Try MM/DD/YYYY
          if (isValidAdParts(yyyy, dd1, mm1)) {
            setTimeout(() => {
              adInput.value = `${String(mm1).padStart(2, "0")}/${String(
                dd1
              ).padStart(2, "0")}/${yyyy}`;
            }, 0);
            return { y: yyyy, m: dd1, d: mm1 };
          }
          return null;
        }

        // Split by separators
        const parts = input
          .split(/[\/\-\.]/)
          .map((s) => parseInt(s))
          .filter((n) => !isNaN(n));
        if (parts.length !== 3) return null;

        const [p1, p2, p3] = parts;

        // Determine year position
        const yearPos = parts.findIndex((p) => p > 31);
        if (yearPos === -1) {
          // No clear year, try different arrangements
          if (p3 > 12) return { y: p3, m: p2, d: p1 }; // DD/MM/YY
          if (p1 > 12) return { y: p3, m: p1, d: p2 }; // MM/DD/YY
          // Default to DD/MM/YY
          return isValidAdParts(p3, p2, p1) ? { y: p3, m: p2, d: p1 } : null;
        }

        const year = parts[yearPos];
        const remaining = parts.filter((_, i) => i !== yearPos);
        const [a, b] = remaining;

        // Try DD/MM or MM/DD
        if (a > 12) return { y: year, m: b, d: a };
        if (b > 12) return { y: year, m: a, d: b };

        // Both could be month or day, prefer DD/MM/YYYY
        return isValidAdParts(year, b, a)
          ? { y: year, m: b, d: a }
          : isValidAdParts(year, a, b)
          ? { y: year, m: a, d: b }
          : null;
      }

      function parseBsInput(input) {
        input = input.replace(/\s/g, "");

        // Handle DDMMYYYY or YYYYMMDD without separators
        if (/^\d{8}$/.test(input)) {
          // Try DDMMYYYY first
          const dd1 = parseInt(input.substring(0, 2));
          const mm1 = parseInt(input.substring(2, 4));
          const yyyy1 = parseInt(input.substring(4, 8));

          if (dd1 > 12 || (dd1 <= 12 && mm1 <= 12 && dd1 > mm1)) {
            if (isValidBsParts(yyyy1, mm1, dd1)) {
              // Auto-format and update display
              setTimeout(() => {
                bsInput.value = `${String(dd1).padStart(2, "0")}/${String(
                  mm1
                ).padStart(2, "0")}/${yyyy1}`;
              }, 0);
              return { y: yyyy1, m: mm1, d: dd1 };
            }
          }

          // Try YYYYMMDD
          const yyyy2 = parseInt(input.substring(0, 4));
          const mm2 = parseInt(input.substring(4, 6));
          const dd2 = parseInt(input.substring(6, 8));
          if (isValidBsParts(yyyy2, mm2, dd2)) {
            // Auto-format and update display
            setTimeout(() => {
              bsInput.value = `${String(dd2).padStart(2, "0")}/${String(
                mm2
              ).padStart(2, "0")}/${yyyy2}`;
            }, 0);
            return { y: yyyy2, m: mm2, d: dd2 };
          }

          // Try MMDDYYYY
          if (isValidBsParts(yyyy1, dd1, mm1)) {
            setTimeout(() => {
              bsInput.value = `${String(mm1).padStart(2, "0")}/${String(
                dd1
              ).padStart(2, "0")}/${yyyy1}`;
            }, 0);
            return { y: yyyy1, m: dd1, d: mm1 };
          }

          return null;
        }

        // Split by separators
        const parts = input
          .split(/[\/\-\.]/)
          .map((s) => parseInt(s))
          .filter((n) => !isNaN(n));
        if (parts.length !== 3) return null;

        const [p1, p2, p3] = parts;

        // Determine year position
        const yearPos = parts.findIndex((p) => p > 31 && p >= 2000);
        if (yearPos !== -1) {
          // Year found, arrange others as day/month
          const year = parts[yearPos];
          const remaining = parts.filter((_, i) => i !== yearPos);
          const [a, b] = remaining;

          // Try DD/MM or MM/DD
          if (a > 12) return { y: year, m: b, d: a };
          if (b > 12) return { y: year, m: a, d: b };

          // Both could be month or day, prefer DD/MM/YYYY
          return isValidBsParts(year, b, a)
            ? { y: year, m: b, d: a }
            : isValidBsParts(year, a, b)
            ? { y: year, m: a, d: b }
            : null;
        }

        // No clear year, assume third position is year
        if (p3 >= 2000 && p3 <= 2089) {
          // DD/MM/YYYY or MM/DD/YYYY
          if (p1 > 12) return { y: p3, m: p2, d: p1 }; // DD/MM/YYYY
          if (p2 > 12) return { y: p3, m: p1, d: p2 }; // MM/DD/YYYY
          // Default to DD/MM/YYYY
          return isValidBsParts(p3, p2, p1)
            ? { y: p3, m: p2, d: p1 }
            : isValidBsParts(p3, p1, p2)
            ? { y: p3, m: p1, d: p2 }
            : null;
        }

        return null;
      }

      function isValidAdParts(y, m, d) {
        if (
          !Number.isInteger(y) ||
          !Number.isInteger(m) ||
          !Number.isInteger(d)
        )
          return false;
        if (y < 1943 || y > 2032) return false;
        if (m < 1 || m > 12) return false;
        const dt = new Date(Date.UTC(y, m - 1, d));
        return (
          dt.getUTCFullYear() === y &&
          dt.getUTCMonth() + 1 === m &&
          dt.getUTCDate() === d
        );
      }

      function isValidBsParts(y, m, d) {
        if (
          !Number.isInteger(y) ||
          !Number.isInteger(m) ||
          !Number.isInteger(d)
        )
          return false;
        if (y < 2000 || y > 2089) return false;
        if (m < 1 || m > 12) return false;
        return d >= 1 && d <= bsMonthData[y][m - 1];
      }

      function showStatus(message, type = "info") {
        const status = document.getElementById("status");
        status.textContent = message;
        status.className = `status ${type}`;
      }

      function clearStatus() {
        const status = document.getElementById("status");
        status.textContent = "";
        status.className = "status";
      }

      const adInput = document.getElementById("adInput");
      const bsInput = document.getElementById("bsInput");

      function debounce(fn, ms) {
        let t;
        return (...args) => {
          clearTimeout(t);
          t = setTimeout(() => fn(...args), ms);
        };
      }

      adInput.addEventListener(
        "input",
        debounce(() => {
          const val = adInput.value.trim();
          adInput.classList.remove("error", "success");

          if (val === "") {
            bsInput.value = "";
            clearStatus();
            return;
          }

          const parsed = parseAdInput(val);
          if (!parsed) {
            adInput.classList.add("error");
            showStatus(
              "Invalid date format. Use DD/MM/YYYY, MM/DD/YYYY, etc.",
              "error"
            );
            return;
          }

          if (!isValidAdParts(parsed.y, parsed.m, parsed.d)) {
            adInput.classList.add("error");
            showStatus("Date out of range. Supported: 1943-2032 AD", "error");
            return;
          }

          try {
            const adDate = new Date(Date.UTC(parsed.y, parsed.m - 1, parsed.d));
            const { y, m, d } = convertAdToBs(adDate);
            bsInput.value = `${String(d).padStart(2, "0")}/${String(m).padStart(
              2,
              "0"
            )}/${y}`;
            adInput.classList.add("success");
            bsInput.classList.add("success");
            showStatus(
              `Converted: ${parsed.d}/${parsed.m}/${parsed.y} AD → ${d}/${m}/${y} BS`,
              "success"
            );
          } catch (e) {
            adInput.classList.add("error");
            showStatus("Conversion error. Please check the date.", "error");
          }
        }, 150)
      );

      bsInput.addEventListener(
        "input",
        debounce(() => {
          const val = bsInput.value.trim();
          bsInput.classList.remove("error", "success");

          if (val === "") {
            adInput.value = "";
            clearStatus();
            return;
          }

          const parsed = parseBsInput(val);
          if (!parsed) {
            bsInput.classList.add("error");
            showStatus(
              "Invalid BS format. Use DD/MM/YYYY, MM/DD/YYYY, or DDMMYYYY",
              "error"
            );
            return;
          }

          if (!isValidBsParts(parsed.y, parsed.m, parsed.d)) {
            bsInput.classList.add("error");
            showStatus("Date out of range. Supported: 2000-2089 BS", "error");
            return;
          }

          try {
            const adDate = convertBsToAd(parsed.y, parsed.m, parsed.d);
            adInput.value = `${String(adDate.getUTCDate()).padStart(
              2,
              "0"
            )}/${String(adDate.getUTCMonth() + 1).padStart(
              2,
              "0"
            )}/${adDate.getUTCFullYear()}`;
            bsInput.classList.add("success");
            adInput.classList.add("success");
            showStatus(
              `Converted: ${parsed.d}/${parsed.m}/${
                parsed.y
              } BS → ${adDate.getUTCDate()}/${
                adDate.getUTCMonth() + 1
              }/${adDate.getUTCFullYear()} AD`,
              "success"
            );
          } catch (e) {
            bsInput.classList.add("error");
            showStatus("Conversion error. Please check the date.", "error");
          }
        }, 150)
      );

      // Clear other field when this one gets focus
      adInput.addEventListener("focus", () => {
        if (bsInput.value && !adInput.value) {
          bsInput.classList.remove("success", "error");
        }
      });

      bsInput.addEventListener("focus", () => {
        if (adInput.value && !bsInput.value) {
          adInput.classList.remove("success", "error");
        }
      });
    </script>
  </body>
</html>
